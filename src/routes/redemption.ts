import { Router } from "express";
import { z } from "zod";
import { AppDataSource } from "../db/data-source";
import { User } from "../entities/User";
import { CouponObject, CouponObjectState } from "../entities/CouponObject";
import { Point } from "../entities/Point";
import { EscrowAccount } from "../entities/EscrowAccount";
import { requireUser, AuthenticatedRequest } from "../middleware/auth";
import { v4 as uuidv4 } from "uuid";
import jwt from "jsonwebtoken";

export const redemptionRouter = Router();

// ÏùºÌöåÏö© ÌÜ†ÌÅ∞ ÏÉùÏÑ± Ïä§ÌÇ§Îßà
const generateTokenSchema = z.object({
  objectId: z.number(),
});

// ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Î∞è ÏÇ¨Ïö© Ïä§ÌÇ§Îßà
const redeemTokenSchema = z.object({
  token: z.string(),
  merchantId: z.number().optional(), // Í∞ÄÎßπÏ†ê ID (ÏÑ†ÌÉùÏÇ¨Ìï≠)
});

/**
 * @openapi
 * /redemption/generate-token:
 *   post:
 *     tags:
 *       - 6Ô∏è‚É£ Ïø†Ìè∞ ÏÇ¨Ïö©
 *     summary: ÏùºÌöåÏö© ÌÜ†ÌÅ∞ ÏÉùÏÑ±
 *     description: Ïò§Î∏åÏ†ùÌä∏ Î≥¥Ïú†ÏûêÍ∞Ä 5Î∂ÑÏßúÎ¶¨ ÏùºÌöåÏö© ÌÜ†ÌÅ∞ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§
 *     parameters:
 *       - in: header
 *         name: auth
 *         schema:
 *           type: string
 *         required: true
 *         description: JWT ÌÜ†ÌÅ∞
 *         example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - objectId
 *             properties:
 *               objectId:
 *                 type: number
 *                 description: ÏÇ¨Ïö©Ìï† Ïò§Î∏åÏ†ùÌä∏ ID
 *     responses:
 *       200:
 *         description: ÌÜ†ÌÅ∞ ÏÉùÏÑ± ÏÑ±Í≥µ
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 token:
 *                   type: string
 *                   description: ÏùºÌöåÏö© ÌÜ†ÌÅ∞
 *                 expiresAt:
 *                   type: string
 *                   format: date-time
 *                   description: ÌÜ†ÌÅ∞ ÎßåÎ£åÏùº
 *                 object:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: number
 *                     couponId:
 *                       type: string
 *                     title:
 *                       type: string
 *                     remaining:
 *                       type: string
 *       400:
 *         description: ÏûòÎ™ªÎêú ÏöîÏ≤≠
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
redemptionRouter.post(
  "/generate-token",
  requireUser,
  async (req: AuthenticatedRequest, res) => {
    try {
      const body = generateTokenSchema.parse(req.body);
      const userId = req.userId!;

      // Ïò§Î∏åÏ†ùÌä∏ ÏÜåÏú†Í∂å ÌôïÏù∏
      const objectRepo = AppDataSource.getRepository(CouponObject);
      const couponObject = await objectRepo.findOne({
        where: {
          id: body.objectId,
          ownerId: userId,
          state: CouponObjectState.CREATED,
        },
      });

      if (!couponObject) {
        return res
          .status(400)
          .json({ error: "Object not found or not owned by you" });
      }

      // ÎßåÎ£åÏùº ÌôïÏù∏
      if (new Date() > couponObject.expiration) {
        return res.status(400).json({ error: "Object has expired" });
      }

      // Ïù¥ÎØ∏ ÏÇ¨Ïö©Îêú ÌÜ†ÌÅ∞Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      if (couponObject.jti) {
        return res
          .status(400)
          .json({ error: "Object already has a pending token" });
      }

      // JTI ÏÉùÏÑ± (Í≥†Ïú†Ìïú ÏùºÌöåÏö© ÌÜ†ÌÅ∞ ID)
      const jti = uuidv4();
      const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5Î∂Ñ ÌõÑ ÎßåÎ£å

      // ÏùºÌöåÏö© ÌÜ†ÌÅ∞ ÏÉùÏÑ±
      const token = jwt.sign(
        {
          jti,
          objectId: body.objectId,
          userId,
          remaining: couponObject.remaining,
          exp: Math.floor(expiresAt.getTime() / 1000), // 5Î∂Ñ ÌõÑ ÎßåÎ£å
        },
        process.env.SESSION_SECRET || "your-secret-key-here",
        {
          algorithm: "HS256",
          issuer: "coutainer-coupon-system",
        }
      );

      // Ïò§Î∏åÏ†ùÌä∏Ïóê JTI Ï†ÄÏû•
      await objectRepo.update(
        { id: body.objectId },
        {
          jti,
          updatedAt: new Date(),
        }
      );

      console.log("üé´ ÏùºÌöåÏö© ÌÜ†ÌÅ∞ ÏÉùÏÑ±:", {
        objectId: body.objectId,
        couponId: couponObject.couponId,
        userId,
        jti,
        expiresAt,
        remaining: couponObject.remaining,
      });

      res.json({
        token,
        expiresAt,
        object: {
          id: couponObject.id,
          couponId: couponObject.couponId,
          title: couponObject.title,
          remaining: couponObject.remaining,
        },
      });
    } catch (err: any) {
      console.error("ÌÜ†ÌÅ∞ ÏÉùÏÑ± Ïò§Î•ò:", err);
      res.status(400).json({ error: err.message });
    }
  }
);

/**
 * @openapi
 * /redemption/verify-token:
 *   post:
 *     tags:
 *       - 6Ô∏è‚É£ Ïø†Ìè∞ ÏÇ¨Ïö©
 *     summary: ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù (Í∞ÄÎßπÏ†êÏö©)
 *     description: Í∞ÄÎßπÏ†êÏóêÏÑú ÏùºÌöåÏö© ÌÜ†ÌÅ∞ÏùÑ Í≤ÄÏ¶ùÌïòÍ≥† ÏÇ¨Ïö©Ìï©ÎãàÎã§
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - token
 *             properties:
 *               token:
 *                 type: string
 *                 description: Í≤ÄÏ¶ùÌï† ÏùºÌöåÏö© ÌÜ†ÌÅ∞
 *               merchantId:
 *                 type: number
 *                 description: Í∞ÄÎßπÏ†ê ID (ÏÑ†ÌÉùÏÇ¨Ìï≠)
 *     responses:
 *       200:
 *         description: ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Î∞è ÏÇ¨Ïö© ÏÑ±Í≥µ
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 object:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: number
 *                     couponId:
 *                       type: string
 *                     title:
 *                       type: string
 *                     remaining:
 *                       type: string
 *                     state:
 *                       type: string
 *                 pointMovements:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       from:
 *                         type: string
 *                       to:
 *                         type: string
 *                       amount:
 *                         type: string
 *                       description:
 *                         type: string
 *       400:
 *         description: ÏûòÎ™ªÎêú ÏöîÏ≤≠
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
redemptionRouter.post("/verify-token", async (req, res) => {
  try {
    const body = redeemTokenSchema.parse(req.body);
    const { token } = body;

    // ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù
    let decoded: any;
    try {
      decoded = jwt.verify(
        token,
        process.env.SESSION_SECRET || "your-secret-key-here"
      );
    } catch (jwtError) {
      return res.status(400).json({ error: "Invalid or expired token" });
    }

    const { jti, objectId, userId, remaining } = decoded;

    // Ïò§Î∏åÏ†ùÌä∏ Ï°∞Ìöå
    const objectRepo = AppDataSource.getRepository(CouponObject);
    const couponObject = await objectRepo.findOne({
      where: {
        id: objectId,
        jti,
        state: CouponObjectState.CREATED,
      },
      relations: ["supplier", "stamp"],
    });

    if (!couponObject) {
      return res
        .status(400)
        .json({ error: "Object not found or already used" });
    }

    // ÎßåÎ£åÏùº ÌôïÏù∏
    if (new Date() > couponObject.expiration) {
      return res.status(400).json({ error: "Object has expired" });
    }

    // JTI Ï§ëÎ≥µ ÏÇ¨Ïö© ÌôïÏù∏ (Ïù¥ÎØ∏ ÏÇ¨Ïö©Îêú ÌÜ†ÌÅ∞Ïù∏ÏßÄ ÌôïÏù∏)
    if (couponObject.usedAt) {
      return res.status(400).json({ error: "Token already used" });
    }

    // Ìä∏ÎûúÏû≠ÏÖò ÏãúÏûë
    const queryRunner = AppDataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // 1. EscrowÏóêÏÑú Í≥µÍ∏âÏûêÏóêÍ≤å remaining Ï†ÑÏï° ÏßÄÍ∏â
      const escrowRepo = queryRunner.manager.getRepository(EscrowAccount);
      const escrowAccount = await escrowRepo.findOne({
        where: { supplierId: couponObject.supplierId },
      });

      if (escrowAccount && BigInt(escrowAccount.balance) >= BigInt(remaining)) {
        // Í≥µÍ∏âÏûê Ìè¨Ïù∏Ìä∏ Ï¶ùÍ∞Ä
        const pointRepo = queryRunner.manager.getRepository(Point);
        const userRepo = queryRunner.manager.getRepository(User);
        const supplier = await userRepo.findOne({
          where: { id: couponObject.supplierId },
        });
        if (!supplier) {
          throw new Error("Supplier not found");
        }

        const supplierPoints = await pointRepo.findOne({
          where: { userAddress: supplier.address },
        });

        if (supplierPoints) {
          await queryRunner.manager.update(
            Point,
            { userAddress: supplier.address },
            {
              balance: (
                BigInt(supplierPoints.balance) + BigInt(remaining)
              ).toString(),
              updatedAt: new Date(),
            }
          );
        } else {
          await queryRunner.manager.save(Point, {
            userAddress: supplier.address,
            balance: remaining,
            updatedAt: new Date(),
          });
        }

        // Escrow ÏûîÏï° Ï∞®Í∞ê
        const newEscrowBalance =
          BigInt(escrowAccount.balance) - BigInt(remaining);
        await queryRunner.manager.update(
          EscrowAccount,
          { id: escrowAccount.id },
          {
            balance: newEscrowBalance.toString(),
            totalReleased: (
              BigInt(escrowAccount.totalReleased) + BigInt(remaining)
            ).toString(),
            updatedAt: new Date(),
          }
        );
      }

      // 2. Ïò§Î∏åÏ†ùÌä∏ ÏÉÅÌÉúÎ•º REDEEMEDÎ°ú Î≥ÄÍ≤Ω
      await queryRunner.manager.update(
        CouponObject,
        { id: objectId },
        {
          state: CouponObjectState.REDEEMED,
          remaining: "0",
          usedAt: new Date(),
          updatedAt: new Date(),
        }
      );

      await queryRunner.commitTransaction();

      // Ìè¨Ïù∏Ìä∏ Ïù¥Îèô ÎÇ¥Ïó≠ ÏÉùÏÑ±
      const pointMovements = [
        {
          from: `escrow_${escrowAccount?.id}`,
          to: `supplier_${couponObject.supplierId}`,
          amount: remaining,
          description: "Ïø†Ìè∞ ÏÇ¨Ïö© ÏôÑÎ£å - remaining Ï†ÑÏï° ÏßÄÍ∏â",
        },
      ];

      console.log("‚úÖ Ïø†Ìè∞ ÏÇ¨Ïö© ÏôÑÎ£å:", {
        objectId,
        couponId: couponObject.couponId,
        jti,
        userId,
        remaining,
        supplier: couponObject.supplierId,
        merchantId: body.merchantId,
      });

      res.json({
        message: "Token verified and coupon redeemed successfully",
        object: {
          id: couponObject.id,
          couponId: couponObject.couponId,
          title: couponObject.title,
          remaining: "0",
          state: CouponObjectState.REDEEMED,
        },
        pointMovements,
      });
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  } catch (err: any) {
    console.error("ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Ïò§Î•ò:", err);
    res.status(400).json({ error: err.message });
  }
});

/**
 * @openapi
 * /redemption/expire-objects:
 *   post:
 *     tags:
 *       - 6Ô∏è‚É£ Ïø†Ìè∞ ÏÇ¨Ïö©
 *     summary: ÎßåÎ£åÎêú Ïò§Î∏åÏ†ùÌä∏ Ï≤òÎ¶¨
 *     description: ÎßåÎ£åÎêú Ïò§Î∏åÏ†ùÌä∏Îì§ÏùÑ Ï≤òÎ¶¨ÌïòÍ≥† remainingÏùÑ Î∞úÌñâÏûêÏóêÍ≤å ÌôòÍ∏âÌï©ÎãàÎã§
 *     responses:
 *       200:
 *         description: ÎßåÎ£å Ï≤òÎ¶¨ ÏôÑÎ£å
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 expiredCount:
 *                   type: number
 *                 refundedAmount:
 *                   type: string
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
redemptionRouter.post("/expire-objects", async (req, res) => {
  try {
    const now = new Date();

    // ÎßåÎ£åÎêú Ïò§Î∏åÏ†ùÌä∏ Ï°∞Ìöå
    const objectRepo = AppDataSource.getRepository(CouponObject);
    const expiredObjects = await objectRepo.find({
      where: {
        state: CouponObjectState.CREATED,
        expiration: { $lt: now } as any, // TypeORMÏóêÏÑú LessThan ÏÇ¨Ïö©
      },
      relations: ["issuer", "supplier"],
    });

    if (expiredObjects.length === 0) {
      return res.json({
        message: "No expired objects found",
        expiredCount: 0,
        refundedAmount: "0",
      });
    }

    // Ìä∏ÎûúÏû≠ÏÖò ÏãúÏûë
    const queryRunner = AppDataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      let totalRefunded = BigInt(0);

      for (const obj of expiredObjects) {
        // 1. Î∞úÌñâÏûêÏóêÍ≤å remaining ÌôòÍ∏â
        const pointRepo = queryRunner.manager.getRepository(Point);
        const userRepo = queryRunner.manager.getRepository(User);
        const issuer = await userRepo.findOne({ where: { id: obj.issuerId } });
        if (!issuer) {
          throw new Error("Issuer not found");
        }

        const issuerPoints = await pointRepo.findOne({
          where: { userAddress: issuer.address },
        });

        if (issuerPoints) {
          await queryRunner.manager.update(
            Point,
            { userAddress: issuer.address },
            {
              balance: (
                BigInt(issuerPoints.balance) + BigInt(obj.remaining)
              ).toString(),
              updatedAt: new Date(),
            }
          );
        } else {
          await queryRunner.manager.save(Point, {
            userAddress: issuer.address,
            balance: obj.remaining,
            updatedAt: new Date(),
          });
        }

        // 2. EscrowÏóêÏÑú ÌôòÍ∏â Í∏àÏï° Ï∞®Í∞ê
        const escrowRepo = queryRunner.manager.getRepository(EscrowAccount);
        const escrowAccount = await escrowRepo.findOne({
          where: { supplierId: obj.supplierId },
        });

        if (escrowAccount) {
          const newEscrowBalance =
            BigInt(escrowAccount.balance) - BigInt(obj.remaining);
          await queryRunner.manager.update(
            EscrowAccount,
            { id: escrowAccount.id },
            {
              balance: newEscrowBalance.toString(),
              totalReleased: (
                BigInt(escrowAccount.totalReleased) + BigInt(obj.remaining)
              ).toString(),
              updatedAt: new Date(),
            }
          );
        }

        // 3. Ïò§Î∏åÏ†ùÌä∏ ÏÉÅÌÉúÎ•º EXPIREDÎ°ú Î≥ÄÍ≤Ω
        await queryRunner.manager.update(
          CouponObject,
          { id: obj.id },
          {
            state: CouponObjectState.EXPIRED,
            remaining: "0",
            updatedAt: new Date(),
          }
        );

        totalRefunded += BigInt(obj.remaining);
      }

      await queryRunner.commitTransaction();

      console.log("‚è∞ ÎßåÎ£åÎêú Ïò§Î∏åÏ†ùÌä∏ Ï≤òÎ¶¨ ÏôÑÎ£å:", {
        expiredCount: expiredObjects.length,
        refundedAmount: totalRefunded.toString(),
      });

      res.json({
        message: "Expired objects processed successfully",
        expiredCount: expiredObjects.length,
        refundedAmount: totalRefunded.toString(),
      });
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  } catch (err: any) {
    console.error("ÎßåÎ£å Ï≤òÎ¶¨ Ïò§Î•ò:", err);
    res.status(500).json({ error: err.message });
  }
});
